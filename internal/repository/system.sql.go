// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: system.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const createOrUpdateSetting = `-- name: CreateOrUpdateSetting :one
insert into system.settings (id, name, data_type, value)
values ( $1, $2, $3, $4)
on conflict (name) do update set value = $4, data_type = $3
returning id, name, data_type, value, created_at, updated_at
`

type CreateOrUpdateSettingParams struct {
	ID       uuid.UUID `json:"id"`
	Name     string    `json:"name"`
	DataType string    `json:"data_type"`
	Value    string    `json:"value"`
}

func (q *Queries) CreateOrUpdateSetting(ctx context.Context, db DBTX, arg *CreateOrUpdateSettingParams) (*SystemSetting, error) {
	row := db.QueryRow(ctx, createOrUpdateSetting,
		arg.ID,
		arg.Name,
		arg.DataType,
		arg.Value,
	)
	var i SystemSetting
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DataType,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createUser = `-- name: CreateUser :one
insert into system.users (username, password, email, full_name)
values ($1, $2, $3, $4)
returning id, username, password, email, full_name, created_at, updated_at
`

type CreateUserParams struct {
	Username string `json:"username"`
	Password string `json:"password"`
	Email    string `json:"email"`
	FullName string `json:"full_name"`
}

// Users
func (q *Queries) CreateUser(ctx context.Context, db DBTX, arg *CreateUserParams) (*SystemUser, error) {
	row := db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.FullName,
	)
	var i SystemUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteSettingByName = `-- name: DeleteSettingByName :exec
delete from system.settings where name = $1
`

func (q *Queries) DeleteSettingByName(ctx context.Context, db DBTX, name string) error {
	_, err := db.Exec(ctx, deleteSettingByName, name)
	return err
}

const getSettingByID = `-- name: GetSettingByID :one
select id, name, data_type, value, created_at, updated_at from system.settings where id = $1
`

func (q *Queries) GetSettingByID(ctx context.Context, db DBTX, id uuid.UUID) (*SystemSetting, error) {
	row := db.QueryRow(ctx, getSettingByID, id)
	var i SystemSetting
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DataType,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSettingByName = `-- name: GetSettingByName :one
select id, name, data_type, value, created_at, updated_at from system.settings where name = $1
`

// System
func (q *Queries) GetSettingByName(ctx context.Context, db DBTX, name string) (*SystemSetting, error) {
	row := db.QueryRow(ctx, getSettingByName, name)
	var i SystemSetting
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DataType,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSettings = `-- name: GetSettings :many
select id, name, data_type, value, created_at, updated_at from system.settings
`

func (q *Queries) GetSettings(ctx context.Context, db DBTX) ([]*SystemSetting, error) {
	rows, err := db.Query(ctx, getSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SystemSetting
	for rows.Next() {
		var i SystemSetting
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DataType,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
select id, username, password, email, full_name, created_at, updated_at from system.users where id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, db DBTX, id uuid.UUID) (*SystemUser, error) {
	row := db.QueryRow(ctx, getUserByID, id)
	var i SystemUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
select id, username, password, email, full_name, created_at, updated_at from system.users where username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, db DBTX, username string) (*SystemUser, error) {
	row := db.QueryRow(ctx, getUserByUsername, username)
	var i SystemUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
